


//#define LOG
//#define DUMP



using System.Text;

using Microsoft.CodeAnalysis;



namespace SourceGenerator
{
	public class CEnumAttribute : Attribute {}
	
	
	
	public static class Extension
	{
		//must
		static int OutputID;//Ensure output.
		
		
		
		public static Diagnostic CreateDiagnostic(string Type, string Text)
		{
			return Diagnostic.Create(
				new DiagnosticDescriptor(
					id: Type,//Must be static
					title: $"{OutputID++}",
					messageFormat: Text,
					category: string.Empty,//"category",
					defaultSeverity: DiagnosticSeverity.Warning,
					isEnabledByDefault: true
				),
				null,
				string.Empty
			);
		}
		
		
		
		public static void Log(this SourceProductionContext This, string Text)
		{
			#if LOG//[
			This.ReportDiagnostic(CreateDiagnostic("SourceProductionContext", Text));
			#endif//]
		}
		
		
		
		public static void Log(this GeneratorExecutionContext This, string Text)
		{
			#if LOG//[
			This.ReportDiagnostic(CreateDiagnostic("GeneratorExecutionContext", Text));
			#endif//]
		}
		
		
		
		public static string Erase(this string This)
		{
			This = This.Replace("\n"," ").Replace("\r","").Replace("\t"," ");
			while (This.IndexOf("  ") >= 0) This = This.Replace("  ", " ");
			return This.Trim();
		}
	}
	
	
	
	public static class Request
	{
		public static Queue<string> EnumPath = new();
	}
	
	
	
	[Generator(LanguageNames.CSharp)]
	public class CEnumIncrementalGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext Context)
		{
			var Log = new Queue<string>();
			
			Context.RegisterPostInitializationOutput(
				/*IncrementalGeneratorPostInitializationContext*/c => {
					var o = new List<string>();
					o.Add($"// <auto-generated/>");
					
					{	// 
						o.Add($"namespace CEnum {{");
						o.Add($"	[AttributeUsage(AttributeTargets.Enum)]");
						o.Add($"	public sealed class CEnumAttribute : Attribute {{}}");
						o.Add($"}}");
					}
					
					{	// 
						var Source = new StringBuilder();
						foreach (var Text in o) Source.AppendLine(Text);
						foreach (var Text in o) Log.Enqueue($"|{Text}");
						
						c.AddSource($"IIncrementalGenerator.g.cs", Source.ToString());
					}
				}
			);
			
			{	// 
				var SyntaxProvider = Context.SyntaxProvider.ForAttributeWithMetadataName(
					"CEnum.CEnumAttribute",
					(SyntaxNode, CancellationToken) => true,//SyntaxNode is EnumDeclarationSyntax,
					(GeneratorAttributeSyntaxContext, CancellationToken) => {
						var ISymbol = GeneratorAttributeSyntaxContext.TargetSymbol;
						var DisplayString = ISymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
						Log.Enqueue($"CEnumAttribute : {DisplayString}");
						
						Request.EnumPath.Enqueue(DisplayString.Replace("global::",""));
						return GeneratorAttributeSyntaxContext;
					}
				).Collect();
				
				Context.RegisterSourceOutput(
					SyntaxProvider,
					(/*SourceProductionContext*/c, aGeneratorAttributeSyntaxContext) => {
						while (Log.Count > 0) c.Log(Log.Dequeue());
					}
				);
			}
		}
	}
	
	
	
	[Generator]
	public class CEnumSourceGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext c)
		{
		}
		
		
		
		public void Execute(GeneratorExecutionContext c)
		{
			var o = new List<string>();
			o.Add($"#nullable enable");
			o.Add($"// <auto-generated/>");
			o.Add($"using System.Text;");
			o.Add($"using System.Numerics;");
			o.Add($"using System.Collections.ObjectModel;");
			o.Add($"using System.Diagnostics.CodeAnalysis;");
			o.Add($"using System.Runtime.CompilerServices;");
			
			{	// 
				var MethodImpl = string.Empty;//"[MethodImpl(MethodImplOptions.AggressiveInlining)] ";
				
				o.Add($"public class CEnum<T> where T : INumber<T> {{");
				o.Add($"	public readonly T Value;");
				o.Add($"	public readonly string Name;");
				o.Add($"	public readonly string? EnumMemberValue;");
				o.Add($"	protected string? StringCache = null;");
				o.Add($"	protected CEnum(T v, string n, string? e = null){{ Value = v; Name = n; EnumMemberValue = e; }}");
				o.Add($"	protected virtual string? ValueToString() => Value.ToString();");
				o.Add($"	{MethodImpl}public static implicit operator T(CEnum<T> This) => This.Value;");
				o.Add($"	{MethodImpl}public new string? ToString(){{ return (StringCache != null)? StringCache: (StringCache = ValueToString()); }}");
				o.Add($"	{MethodImpl}public string? GetEnumMemberValue() => EnumMemberValue;");
				o.Add($"}}");
			}
			
			while (Request.EnumPath.Count > 0){
				var Path = Request.EnumPath.Dequeue();
				
				var MetadataName = Path;
				var INamedTypeSymbol = c.Compilation.GetTypeByMetadataName(MetadataName);
				while (INamedTypeSymbol == null){
					var i = MetadataName.LastIndexOf('.');
					if (i >= 0){
						var a = MetadataName.ToCharArray();
						a[i] = '+';
						MetadataName = new string(a);
						
						INamedTypeSymbol = c.Compilation.GetTypeByMetadataName(MetadataName);
					} else {
						break;
					}
				}
				c.Log($"{MetadataName}.{INamedTypeSymbol != null}");
				
				#if DUMP//[
				if (INamedTypeSymbol != null){
					foreach (var AttributeData in INamedTypeSymbol.GetAttributes()){
						DumpAttributeData(c, AttributeData);
					}
					
					switch (INamedTypeSymbol.TypeKind){
						case TypeKind.Enum:{
							c.Log($"{INamedTypeSymbol.EnumUnderlyingType}");
							foreach (var Member in INamedTypeSymbol.GetMembers().OfType<IFieldSymbol>()){
								foreach (var AttributeData in Member.GetAttributes()){
									DumpAttributeData(c, AttributeData);
								}
								c.Log($"{Member.Name}.{Member.ConstantValue}");
							}
							break;
						}
					}
				}
				#endif//]
				
				GeneratEnum(c, ref o, MetadataName, INamedTypeSymbol);
			}
			
			{	// 
				var Source = new StringBuilder();
				foreach (var Text in o) Source.AppendLine(Text);
				foreach (var Text in o) c.Log($"|{Text}");
				
				c.AddSource($"ISourceGenerator.g.cs", Source.ToString());
			}
		}
		
		
		
		void DumpAttributeData(GeneratorExecutionContext c, AttributeData AttributeData)
		{
			c.Log($"-> {AttributeData.AttributeClass?.Name}");
			foreach (var Argument in AttributeData.ConstructorArguments){
				switch (Argument.Kind){
					case TypedConstantKind.Array:{
						c.Log($"-> ConstructorArguments : {Argument.Kind} : {Argument.Type?.Name} : {Argument.Values}");
						int i = 0;
						foreach (var Value in Argument.Values){
							c.Log($"-> ConstructorArguments[{i++}] : {Value.Kind} : {Value.Type?.Name} : {Value.Value}");
						}
						break;
					}
					case TypedConstantKind.Enum:
					case TypedConstantKind.Error:
					case TypedConstantKind.Primitive:
					case TypedConstantKind.Type:
					{
						c.Log($"-> ConstructorArguments : {Argument.Kind} : {Argument.Type?.Name} : {Argument.Value}");
						break;
					}
				}
			}
			foreach (var Argument in AttributeData.NamedArguments){
				c.Log($"-> NamedArguments : {Argument.Key} : {Argument.Value.Kind} : {Argument.Value.Type?.Name} : {Argument.Value.Value} : {Argument.Value.Value?.GetType().Name}");
			}
		}
		
		
		
		void GeneratEnum(GeneratorExecutionContext c, ref List<string> o, string MetadataName, INamedTypeSymbol? INamedTypeSymbol)
		{
			if (INamedTypeSymbol != null){
				var aPath = new Stack<string>();
				
				{	// 
					var Path = MetadataName;
					aPath.Push(Path);
					
					var i = Path.LastIndexOfAny(new char[]{'.','+'});
					while (i >= 0){
						Path = Path.Substring(0, i);
						aPath.Push(Path);
						if (c.Compilation.GetTypeByMetadataName(Path) == null) break;
						
						i = Path.LastIndexOfAny(new char[]{'.','+'});
					}
				}
				
				{	// 
					const int Tab = 2;
					string IndentInc(StringBuilder s) => s.Append("  ").ToString();
					string IndentDec(StringBuilder s) => (s.Length >= Tab)? s.Remove((s.Length - Tab), Tab).ToString(): string.Empty;
					var s = new StringBuilder(32);
					
					var I = string.Empty;
					while (aPath.Count > 0){
						var Path = aPath.Pop();
						var PathINamedTypeSymbol = c.Compilation.GetTypeByMetadataName(Path);
						if (PathINamedTypeSymbol == null){
							// namespace
							o.Add($"{I}namespace {Path} {{");
							I = IndentInc(s);
						} else {
							// type
							var i = Path.LastIndexOfAny(new char[]{'.','+'});
							var Identifier = (i < 0)? Path: Path.Substring(i+1);
							var Accessiblity = PathINamedTypeSymbol.DeclaredAccessibility.ToString().ToLower();
							switch (PathINamedTypeSymbol.TypeKind){
								case TypeKind.Class:{
									o.Add($"{I}{Accessiblity} partial class {Identifier} {{");
									I = IndentInc(s);
									break;
								}
								case TypeKind.Enum:{
									var EType = PathINamedTypeSymbol.EnumUnderlyingType;
									var EName = $"{Identifier}";
									var CName = $"C{EName}";
									var MethodImpl = string.Empty;//"[MethodImpl(MethodImplOptions.AggressiveInlining)] ";
									var IsLong = (EType?.ToString() == "long");
									var IsFlags = false;
									
									foreach (var AttributeData in PathINamedTypeSymbol.GetAttributes()){
										if (AttributeData.AttributeClass == null) continue;
										if (AttributeData.AttributeClass.Name == "FlagsAttribute"){
											IsFlags = true;
											continue;
										}
									}
									
									o.Add($"{I}{Accessiblity} class {CName} : CEnum<{EType}> {{");
									I = IndentInc(s);
									{	// 
										var IsContinuous = true;
										
										// Member
										int? Min = null;
										int? Value = null;
										int Length = 0;
										foreach (var Member in PathINamedTypeSymbol.GetMembers().OfType<IFieldSymbol>()){
											var EnumMemberValue = "null";
											
											foreach (var AttributeData in Member.GetAttributes()){
												if (AttributeData.AttributeClass == null) continue;
												if (AttributeData.AttributeClass.Name == "EnumMemberAttribute"){
													foreach (var Argument in AttributeData.NamedArguments){
														if (Argument.Key == "Value" && Argument.Value.Value is string ArgumentValueValue){
															EnumMemberValue = $@"""{ArgumentValueValue}""";
														}
													}
													continue;
												}
											}
											
											var Name = Member.Name;
											var ConstantValue = (Member.ConstantValue != null)? Convert.ToInt32(Member.ConstantValue): 0;
											o.Add($@"{I}public static readonly {CName} C{Name} = new({Member.ConstantValue}, ""C{Name}"", {EnumMemberValue});");
											Min ??= ConstantValue;
											Value ??= ConstantValue;
											IsContinuous = (IsContinuous)? (ConstantValue == Value): IsContinuous;
											++Value;
											++Length;
										}
										
										// Length
										o.Add($"{I}public const int Length = {Length};");
										
										// Constructor
										o.Add($"{I}protected {CName}({EType} v, string n, string? e):base(v, n, e){{}}");
										
										// aMember
										o.Add($"{I}protected static readonly {CName}[] aMember = new {CName}[]{{");
										I = IndentInc(s);
										foreach (var Member in PathINamedTypeSymbol.GetMembers().OfType<IFieldSymbol>()){
											o.Add($"{I}C{Member.Name},");
										}
										I = IndentDec(s);
										o.Add($"{I}}};");
										
										// aValue
										o.Add($"{I}protected static readonly {EType}[] aValue = new {EType}[]{{");
										I = IndentInc(s);
										foreach (var Member in PathINamedTypeSymbol.GetMembers().OfType<IFieldSymbol>()){
											o.Add($"{I}{Member.ConstantValue},");
										}
										I = IndentDec(s);
										o.Add($"{I}}};");
										
										// aName
										o.Add($"{I}protected static readonly string[] aName = new string[]{{");
										I = IndentInc(s);
										foreach (var Member in PathINamedTypeSymbol.GetMembers().OfType<IFieldSymbol>()){
											o.Add($@"{I}""C{Member.Name}"",");
										}
										I = IndentDec(s);
										o.Add($"{I}}};");
										
										// Collection
										o.Add($"{I}static readonly ReadOnlyCollection<{CName}> Members = aMember.AsReadOnly();");
										o.Add($"{I}static readonly ReadOnlyCollection<{EType}> Values = aValue.AsReadOnly();");
										o.Add($"{I}static readonly ReadOnlyCollection<string> Names = aName.AsReadOnly();");
										
										// ValueToMember
										if (IsFlags || !IsContinuous) o.Add($"{I}static readonly Dictionary<{EType}, {CName}> ValueToMember = new({Length});");
										
										// NameToMember
										o.Add($"{I}static readonly Dictionary<int, {CName}> NameToMember = new({Length});");
										o.Add($"{I}static readonly Dictionary<int, {CName}> nametomember = new({Length});");
										
										// FlagsMask
										if (IsFlags){
											o.Add($"{I}static readonly {EType} FlagsMask;");
										}
										
										// Initialize
										o.Add($"{I}static {CName}(){{");
										I = IndentInc(s);
										{	// 
											if (IsFlags || !IsContinuous){
												o.Add($"{I}foreach (var m in aMember){{");
												I = IndentInc(s);
												{	// 
													o.Add($"{I}try {{ ValueToMember.Add(m.Value, m); }}");
													o.Add($"{I}catch (Exception){{}}");
												}
												I = IndentDec(s);
												o.Add($"{I}}}");
											}
											o.Add($"{I}foreach (var m in aMember) NameToMember.Add(m.Name.GetHashCode(), m);");
											o.Add($"{I}foreach (var m in aMember) nametomember.Add(m.Name.ToLower().GetHashCode(), m);");
											if (IsFlags){
												o.Add($"{I}foreach (var m in aMember) FlagsMask |= m.Value;");
											}
										}
										I = IndentDec(s);
										o.Add($"{I}}}");
										
										// ToCEnum
										if (IsFlags){
											o.Add($"{I}{MethodImpl}static {CName} ToCEnum({EType} Value) => (ValueToMember.TryGetValue(Value, out var m))? m: new {CName}(Value, string.Empty, null);");
										} else {
											if (IsContinuous){
												if (Min == null || Min == 0){
													o.Add($"{I}{MethodImpl}static {CName} ToCEnum({EType} Value) => aMember[Value];");
												} else {
													o.Add($"{I}{MethodImpl}static {CName} ToCEnum({EType} Value) => aMember[Value - {Min}];");
												}
											} else {
												o.Add($"{I}{MethodImpl}static {CName} ToCEnum({EType} Value) => ValueToMember[Value];");
											}
										}
										o.Add($"{I}{MethodImpl}static {CName} ToCEnum(string Name) => NameToMember[Name.GetHashCode()];");
										
										// Cast
										o.Add($"{I}{MethodImpl}public static implicit operator {EName}({CName} c) => ({EName})c.Value;");
										o.Add($"{I}{MethodImpl}public static implicit operator {CName}({EName} {EName}) => Parse(({EType}){EName});");
										o.Add($"{I}{MethodImpl}public static explicit operator {CName}({EType} Value) => Parse(Value);");
										o.Add($"{I}{MethodImpl}public static explicit operator {CName}(string Name) => ToCEnum(Name);");
										
										// GetUnderlyingType
										o.Add($"{I}public static Type GetUnderlyingType() => typeof({EType});");
										
										// Parse
										if (IsFlags){
											o.Add($"{I}{MethodImpl}public static {CName} Parse({EType} Value){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}if (TryParse(Value, out var Result)) return Result;");
												o.Add($"{I}throw new ArgumentException();");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
										} else {
											o.Add($"{I}{MethodImpl}public static {CName} Parse({EType} Value) => ToCEnum(Value);");
										}
										o.Add($"{I}public static {CName} Parse(string Names){{");
										I = IndentInc(s);
										{	// 
											o.Add($"{I}if (TryParse(Names, out var Result)) return Result;");
											o.Add($"{I}throw new ArgumentException();");
										}
										I = IndentDec(s);
										o.Add($"{I}}}");
										o.Add($"{I}public static {CName} Parse(string Names, bool ignoreCase){{");
										I = IndentInc(s);
										{	// 
											o.Add($"{I}if (TryParse(Names, ignoreCase, out var Result)) return Result;");
											o.Add($"{I}throw new ArgumentException();");
										}
										I = IndentDec(s);
										o.Add($"{I}}}");
										
										// TryParse
										if (IsFlags){
											o.Add($"{I}{MethodImpl}public static bool TryParse({EType} Value, [NotNullWhen(true)] out {CName}? Result){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}if ((~FlagsMask & Value) != 0){{ Result = null; return false; }}");
												o.Add($"{I}Result = ToCEnum(Value); return true;");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
										} else {
											if (IsContinuous){
												o.Add($"{I}{MethodImpl}public static bool TryParse({EType} Value, [NotNullWhen(true)] out {CName}? Result){{");
												I = IndentInc(s);
												{	// 
													if (Min == null || Min == 0){
														o.Add($"{I}if (Value < 0 || Value >= {Length}){{ Result = null; return false; }}");
														o.Add($"{I}Result = ToCEnum(Value); return true;");
													} else {
														o.Add($"{I}if (Value < {Min} || Value >= {Length + Min}){{ Result = null; return false; }}");
														o.Add($"{I}Result = ToCEnum(Value); return true;");
													}
												}
												I = IndentDec(s);
												o.Add($"{I}}}");
											} else {
												o.Add($"{I}{MethodImpl}public static bool TryParse({EType} Value, [NotNullWhen(true)] out {CName}? Result) => ValueToMember.TryGetValue(Value, out Result);");
											}
										}
										if (IsFlags){
											o.Add($"{I}public static bool TryParse(string Names, [NotNullWhen(true)] out {CName}? Result){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}{EType} Value = default;");
												o.Add($"{I}var aToken = Names.Split(',', (StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries));");
												o.Add($"{I}foreach (var Token in aToken) if (NameToMember.TryGetValue(Token.GetHashCode(), out var m)) Value |= m.Value; else {{ Result = null; return false; }}");
												o.Add($"{I}Result = ToCEnum(Value); return true;");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
											o.Add($"{I}public static bool TryParse(string Names, bool ignoreCase, [NotNullWhen(true)] out {CName}? Result){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}{EType} Value = default;");
												o.Add($"{I}var aToken = Names.Split(',', (StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries));");
												o.Add($"{I}foreach (var Token in aToken) if (nametomember.TryGetValue(Token.ToLower().GetHashCode(), out var m)) Value |= m.Value; else {{ Result = null; return false; }}");
												o.Add($"{I}Result = ToCEnum(Value); return true;");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
										} else {
											o.Add($"{I}public static bool TryParse(string Names, [NotNullWhen(true)] out {CName}? Result) => NameToMember.TryGetValue(Names.GetHashCode(), out Result);");
											o.Add($"{I}public static bool TryParse(string Names, bool ignoreCase, [NotNullWhen(true)] out {CName}? Result){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}return (ignoreCase)? nametomember.TryGetValue(Names.ToLower().GetHashCode(), out Result): NameToMember.TryGetValue(Names.GetHashCode(), out Result);");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
										}
										
										// IsDefined
										o.Add($"{I}{MethodImpl}public static bool IsDefined({EType} Value) => TryParse(Value, out var _);");
										o.Add($"{I}{MethodImpl}public static bool IsDefined(string Names) => TryParse(Names, out var _);");
										
										// GetMembers
										o.Add($"{I}public static ReadOnlyCollection<{CName}> GetMembers => Members;");
										
										// GetValues
										o.Add($"{I}public static ReadOnlyCollection<{EType}> GetValues => Values;");
										
										// GetNames
										o.Add($"{I}public static ReadOnlyCollection<string> GetNames => Names;");
										
										// GetName
										o.Add($"{I}{MethodImpl}public static string GetName({CName} Member) => Member.Name;");
										
										// operator
										o.Add($"{I}{MethodImpl}public override bool Equals(object? o) => (o is {CName} c)? (Value == c.Value): false;");
										if (IsLong){
											o.Add($"{I}{MethodImpl}public override int GetHashCode() => (int)Value;");
										} else {
											o.Add($"{I}{MethodImpl}public override int GetHashCode() => Value;");
										}
										o.Add($"{I}{MethodImpl}public static bool operator ==({CName} a, {CName} b) => (a.Value == b.Value);");
										o.Add($"{I}{MethodImpl}public static bool operator !=({CName} a, {CName} b) => (a.Value != b.Value);");
										if (IsFlags){
											o.Add($"{I}{MethodImpl}public static {CName} operator &({CName} a, {CName} b) => ToCEnum(({EType})(a.Value & b.Value));");
											o.Add($"{I}{MethodImpl}public static {CName} operator |({CName} a, {CName} b) => ToCEnum(({EType})(a.Value | b.Value));");
											o.Add($"{I}{MethodImpl}public static {CName} operator ^({CName} a, {CName} b) => ToCEnum(({EType})(a.Value ^ b.Value));");
											o.Add($"{I}{MethodImpl}public static {CName} operator ~({CName} c) => ToCEnum(({EType})~c.Value);");
										}
										
										// Flag
										if (IsFlags){
											o.Add($"{I}{MethodImpl}public bool HasFlag({CName} Flags) => ((Value & Flags.Value) == Flags.Value);");
											o.Add($"{I}{MethodImpl}public bool AllFlag({CName} Flags) => ((Value & Flags.Value) == Flags.Value);");
											o.Add($"{I}{MethodImpl}public bool AnyFlag({CName} Flags) => ((Value & Flags.Value) != default({EType}));");
											o.Add($"{I}{MethodImpl}public bool NotFlag({CName} Flags) => ((Value & Flags.Value) == default({EType}));");
											o.Add($"{I}{MethodImpl}public bool OtherAllFlag({CName} Flags) => ((Value & ~Flags.Value) == ~Flags.Value);");
											o.Add($"{I}{MethodImpl}public bool OtherAnyFlag({CName} Flags) => ((Value & ~Flags.Value) != default({EType}));");
											o.Add($"{I}{MethodImpl}public bool OtherNotFlag({CName} Flags) => ((Value & ~Flags.Value) == default({EType}));");
										}
										
										// ValueToString
										if (IsFlags){
											o.Add($"{I}protected override string? ValueToString(){{");
											I = IndentInc(s);
											{	// 
												o.Add($"{I}var c = string.Empty;");
												o.Add($"{I}var s = new StringBuilder(32);");
												o.Add($"{I}foreach (var m in Members){{");
												I = IndentInc(s);
												{	// 
													if (IsLong){
														o.Add($"{I}if (BitOperations.PopCount((ulong)m.Value) == 1 && (m.Value & Value) != 0){{");
													} else {
														o.Add($"{I}if (BitOperations.PopCount((uint)m.Value) == 1 && (m.Value & Value) != 0){{");
													}
													I = IndentInc(s);
													{	// 
														o.Add($@"{I}s.Append($""{{c}}{{m.Name}}"");");
														o.Add($@"{I}c = "", "";");
													}
													I = IndentDec(s);
													o.Add($"{I}}}");
												}
												I = IndentDec(s);
												o.Add($"{I}}}");
												o.Add($"{I}return s.ToString();");
											}
											I = IndentDec(s);
											o.Add($"{I}}}");
										}
									}
									I = IndentDec(s);
									o.Add($"{I}}}");
									break;
								}
							}
						}
					}
					while (!string.IsNullOrEmpty(I)){
						I = IndentDec(s);
						o.Add($"{I}}}");
					}
				}
			}
		}
	}
}
